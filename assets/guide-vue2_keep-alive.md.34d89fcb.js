import{_ as s,o as a,c as n,d as l}from"./app.d991dbbc.js";const d=JSON.parse('{"title":"二级页面缓存","description":"","frontmatter":{},"headers":[{"level":2,"title":"标签栏关闭","slug":"标签栏关闭","link":"#标签栏关闭","children":[]},{"level":2,"title":"标签栏开启","slug":"标签栏开启","link":"#标签栏开启","children":[]}],"relativePath":"guide-vue2/keep-alive.md"}'),p={name:"guide-vue2/keep-alive.md"},o=l(`<h1 id="二级页面缓存" tabindex="-1">二级页面缓存 <a class="header-anchor" href="#二级页面缓存" aria-hidden="true">#</a></h1><p>由于专业版提供了标签栏功能，而标签栏开启和关闭是两种不同的缓存处理逻辑，避免两种逻辑冲突，在框架开发前需要确定标签栏是否开启或关闭。基础版只需阅读<strong>标签栏关闭</strong>部分。</p><h2 id="标签栏关闭" tabindex="-1">标签栏关闭 <a class="header-anchor" href="#标签栏关闭" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">说明</p><p>页面缓存只支持跳转至平级或下级路由，跳转上级路由则无法缓存，以下介绍建议结合代码与演示加深理解。</p><p>页面缓存是通过 Vue 内置的 <a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noreferrer"><code>&lt;keep-alive /&gt;</code></a> 组件的 <code>include</code> 特性实现，如果想深入了解框架实现方式，请先确保自己了解 <code>&lt;keep-alive /&gt;</code> 组件。</p></div><p>多级页面缓存最常见的一个使用场景就是列表页和详情页，例如一个新闻模块，我在列表页修改了搜索条件，然后又翻了几页，最后点击进入某篇新闻的详情页，进行编辑操作后，返回列表页，这时候列表页已经是初始状态了，如果我还想继续之前的操作，就得重新修改搜索条件，然后翻页到之前的页数，这样的设计明显是不合理的。</p><p>框架在这块已经做好了基础功能封装，你只需要知道如何调用，就可以实现页面缓存的需求了。我们来看下实际应用代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">beforeRouteEnter</span><span style="color:#A6ACCD;">(to</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> from</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> next) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 进入页面时，先将当前页面的 name 信息存入 keep-alive 全局状态</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">next</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">vm</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">vm</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">$store</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">commit</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">keepAlive/add</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ListPageName</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#82AAFF;">beforeRouteLeave</span><span style="color:#A6ACCD;">(to</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> from</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> next) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 因为并不是所有的路由跳转都需要将当前页面进行缓存，例如最常见的情况，从列表页进入详情页，则需要将列表页缓存，而从列表页跳转到其它页面，则不需要将列表页缓存</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 所以下面的代码意思就是，如果目标路由的 name 不是 detailRouterName 或 otherDetailRouterName ，则将当前页面的 name 从 keep-alive 中删除</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#F07178;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">detailRouterName</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">otherDetailRouterName</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">to</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 注意：上面校验的是路由的 name ，下面记录的是当前页面的 name</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$store</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">commit</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">keepAlive/remove</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ListPageName</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">next</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通过上面的例子，我们可以知道，页面缓存的核心实现都离不开路由的 name ，所以在配置路由的时候，必须给每个路由设置上 name 属性，并确保 name 唯一。</p><p>解决了缓存的问题，另一个需求就产生了，就是页面虽然缓存了，那页面上的数据要怎么更新了，比如在详情页编辑了新闻，返回列表页的时候，如何更新列表页的数据。</p><p>要解决这个问题，就得引入事件总线的概念了，事件总线就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，组件可以上下平行地通知其他组件。框架已经封装好了事件总线，看下如何使用吧。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 列表页</span></span>
<span class="line"><span style="color:#82AAFF;">mounted</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">getDataList</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 将 getDataList() 方法绑定到事件总线上</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$eventBus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">$on</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">getDataList</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">getDataList</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#82AAFF;">beforeDestroy</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// 页面销毁时解绑事件总线上的 getDataList() 方法</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$eventBus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">$off</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">getDataList</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 详情页</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 在需要更新列表的地方，通过事件总线更新列表页数据</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$eventBus</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">$emit</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">getDataList</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><h2 id="标签栏开启" tabindex="-1">标签栏开启 <a class="header-anchor" href="#标签栏开启" aria-hidden="true">#</a></h2><p>当开启标签栏功能后，每一个打开的标签页都会进行缓存，前提是页面组件必须设置过 <code>name</code> ，是组件的 <code>name</code> ，不是路由的 <code>name</code> 。</p><p>缓存太多页面会造成浏览器性能不必要的开销，所以如果部分页面无需缓存，将页面组件的 <code>name</code> 删除即可。</p>`,14),e=[o];function t(c,r,F,y,D,i){return a(),n("div",null,e)}const C=s(p,[["render",t]]);export{d as __pageData,C as default};
